ТЗ 3

- Движение дальше — доработать приложение для запуска нескольких узлов объединённых репликацией
  - сделать систему транзакций на основе json patch
    - псевдокод
    - newsnap = patch(snap, transaction)
  - построить репликацию
  - поток отправки транзакций без оптимизации
    - псевдокод

    for transaction in range wal {
        send transaction
    }

  - поток применения
    - псевдокод

    for {
        transaction <- stream
        if transaction already applied {
            continue
        }
        newsnap = patch(snap, transaction)
    }

- JSON patch
  - Например
  - Было
    { "baz": "qux", "foo": "bar" }
  - Патч
  [
    { "op": "replace", "path": "/baz", "value": "boo" },
    { "op": "add", "path": "/hello", "value": ["world"] },
    { "op": "remove", "path": "/foo" }
  ]
  - Стало
    { "baz": "boo", "hello": ["world"] }

- WebSocket это канал постоянной двустороней связи используя http
    - Может работать между браузером и сервером
    - Может работать между двумя серверами

- потребуются библиотечки!!!
  - go get github.com/evanphx/json-patch/v5
    - для транзакций
  - go get nhooyr.io/websocket
    - для вебсокетов

- сделать http сервер
  - /test отдает статический файл index.html (*)
    - файл для отладки присходящего
    - файл готовый (см ниже)
    - файл прикрепить к приложеньке с помощью embed
  - /vclock отдаёт текущий vclock
  - /replace (можно переименовать в /post) принимает data
    - создаёт транзакцию по структуре ниже (1)
    - отправляет в менеджер (2)
  - /get берет у менеджера состояние (3)
  - /ws отправляет репликационный поток (5)

- менеджер транзакций умеет (2)
  - применить транзакцию к snap (3)
    - patch := jsonpatch.DecodePatch ...
    - patch.Apply ...
  - записать в журнал (4)
  - должен учитывать vclock и если vclock[Source] больше чем Id самой транзакции,
    то транзакцию не применять

- у нас есть снапшот
  - глобальная переменная
  - snap: string (3)
  - значение переменной на запуске это пустой json объект
  - "{}"

- у нас есть журнал транзакций
  - глобальная переменная с массивом транзакций
  - wal: []string (4)

- транзакция в журнале должна быть структурой (1)
  - struct
    - Source: string     - ваша фамилия
    - Id: uint64         - возрастающий счетчик
    - Payload: string    - транзакция

- транзакция это строка внутри, которой JSON patch

- у нас есть логические часы
  - глобальная переменная
  - это мапка map[string]uint64
    Например:
    {
        filonenko:100,
        madzhuga:0
    }

- у нас есть глобальная переменная, в которой мы хардкодим Source нашего узла
- у нас есть глобальная переменная — локальный счётчик наших транзакций, который мы инкрементим каждую локальную транзакцию

- у нас есть глобальная переменная, в которой перечислены все наши соседи
  - peers []string

Репликация:
- состоит из
  - websocket handler (5)
    - установлен на роут /ws
    - c, err := websocket.Accept(w, r, &websocket.AcceptOptions{
   InsecureSkipVerify: true,
   OriginPatterns:     []string{"*"},
  })
    - wsjson.Write(r.Context(), c, transaction)
    - отправляет репликационный поток
    - при новом входящем соединении регистрирует себя в менеджере транзакций
  - websocket client
    - это несколько горутин по одной на каждый peer из переменной peers
    - c, _, err := websocket.Dial(ctx, fmt.Sprintf("ws://%s/ws", peer), nil)
    - wsjson.Read(r.Context(), c, transaction)
    - принимает репликационный поток
    - отправляет принятое в менеджер транзакций

Внимание! Для менеджера транзакции из репликации и от пользователя должны быть одинаковыми (неразличимы).

- Чтобы проверить работу приложения запустить в двух экземплярах
  - на 8080
  - на 8081
И указать соседей в peers

После перейти на урл /test и ввести транзакции

[{"op":"replace", "path": "/0", "value": []}]
[{"op":"add", "path": "/0/-", "value": "Hello"}]
[{"op":"add", "path": "/0/-", "value": "World"}]

В результате /get должен выглядеть

{"0":["Hello","World"]}


Сделать к 9-ому числу
Присылать файлы в личку, гитхаб ссылки
